import socket
import pickle


def _pass(addr):
    '''
    >>> _pass(addr: Tuple[str, int]) -> None
    '''
    pass


class IServer:
    def __init__(
        self,
        addr=('0.0.0.0', 0),
        buffer_size=4096,
        listen_n=1,
        verbose=False
    ):
        '''
        >>> IServer(
                addr: Tuple[str, int] = ('0.0.0.0', 0),
                buffer_size: int = 4096,
                listen_n: int = 1,
                verbose: bool = False
            ) -> IServer
        '''
        self.buffer_size = buffer_size
        self.verbose = verbose

        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind(addr)
        self.addr = self.server.getsockname()
        self.server.listen(listen_n)

        self.client_connect_callback = _pass
        self.client_close_callback = _pass
        self.func_name = dict()
        self.add_func(eval, '_inincompatibility_remote_eval')
        self.add_func(exec, '_inincompatibility_remote_exec')

    def _eval_from_data(self, b):
        '''
        >>> _eval_from_data(b: bytes) -> bytes
        '''
        func, args, kwargs = pickle.loads(b)
        assert isinstance(func, str)
        assert isinstance(args, tuple)
        assert isinstance(kwargs, dict)
        assert func in self.func_name
        if self.verbose:
            print('_eval', func, args, kwargs)
        try:
            res = self.func_name[func](*args, **kwargs)
        except Exception as e:
            res = e
        return pickle.dumps(res)

    def add_func(self, func, name=None, errors='strict'):
        '''
        >>> add_func(
                func: Callable,
                name: str = None,
                errors: Literal['ignore', 'replace', 'strict'] = 'ignore'
            ) -> None
        '''
        # 'ignore' 'replace' 'strict'
        assert callable(func)
        if name is None:
            name = func.__name__
        if name in self.func_name:
            print('Warning: Function name "%s" already exists' % name)
            if errors == 'ignore':
                return
            elif errors == 'replace':
                pass
            elif errors == 'strict':
                raise ValueError('Function name "%s" already exists' % name)
            else:
                raise ValueError('Invalid value for `errors`')
        if self.verbose:
            print('_add_func', name, func)
        self.func_name[name] = func

    def add_funcs(self, *args):
        '''
        >>> add_funcs(
                *args: Callable | Iterable[Callable]
            ) -> None
        '''
        for fs in args:
            if isinstance(fs, (list, tuple)):
                for f in fs:
                    self.add_func(f)
            else:
                self.add_func(fs)

    def join_client(self):
        '''
        >>> join_client() -> None
        '''
        client_socket, client_addr = self.server.accept()
        print('Connected by', client_addr)
        self.client_connect_callback(client_addr)
        while True:
            data = client_socket.recv(self.buffer_size)
            if not data:
                break
            res = self._eval_from_data(data)
            client_socket.sendall(res)
        client_socket.close()
        print('Closed by', client_addr)
        self.client_close_callback(client_addr)

    def join(self):
        '''
        >>> join() -> None
        '''
        print('Server started at', self.addr)
        # print('Now you can connect to this server.')
        while True:
            self.join_client()
        self.close()

    def run(self):
        '''
        >>> run() -> None
        '''
        self.join()

    def close(self):
        '''
        >>> close() -> None
        '''
        return self.server.close()

    def gen_import_code(self, p='to_import.py', addr=None):
        '''
        >>> gen_import_code(
                p: str = 'to_import.py',
                addr: Tuple[str, int] | None = None
            ) -> str
        '''
        server_ip, server_port = self.addr
        if addr is None:
            ip = server_ip
            port = server_port
        else:
            ip, port = addr
            if port == 0:
                port = server_port
        if ip == '0.0.0.0':
            ip = '127.0.0.1'

        generated_script = '''# Generated by `inincompatibility`.
# But **not** depend on `incompatibility`. :)
# Please use this file instead of the original file to `import`.
import socket
import pickle\n
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(''' + str((ip, port)) + ''')\n
BUFFER_SIZE = ''' + str(self.buffer_size) + '''\n\n
def _func_eval(func, args, kwargs):
    data = pickle.dumps((func, args, kwargs))
    client.sendall(data)
    return pickle.loads(client.recv(BUFFER_SIZE))\n'''
        for name in self.func_name:
            generated_script += '''\n
def ''' + name + '''(*args, **kwargs):
    return _func_eval("''' + name + '''", args, kwargs)\n'''

        import os
        if os.path.exists(p):
            # raise FileExistsError('File already exists')
            pass
        else:
            os.makedirs(os.path.dirname(os.path.abspath(p)), exist_ok=True)
        with open(p, 'wb') as f:
            f.write(generated_script.encode('utf-8'))
        print('Generated at:', repr(p))
        return p
